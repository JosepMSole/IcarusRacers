<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ICARUS RACERS (v0.7)</title>
  <style>
    html, body { margin:0; height:100%; background:#070b18; color:#e6f0ff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }
    #wrap { height:100%; display:grid; place-items:center; }
    canvas{
      width:min(1200px,96vw);
      /* Mantén proporción para evitar deformaciones en mobile */
      aspect-ratio: 1200 / 760;
      height:auto;
      max-height:min(760px,92svh);
      border-radius:16px;
      box-shadow:0 18px 60px rgba(0,0,0,.45);
      background: radial-gradient(1200px 700px at 60% 40%, #0f1a3a 0%, #070b18 55%, #040611 100%);
    }

    .hud{
      position:fixed; left:14px; top:14px; right:14px;
      display:flex; gap:12px; flex-wrap:wrap; align-items:center;
      pointer-events:none;
      z-index:5;
    }
    .pill{
      padding:8px 12px; border-radius:999px;
      background:rgba(10,16,34,.55);
      border:1px solid rgba(180,210,255,.12);
      backdrop-filter:blur(8px);
      font-size:13px;
    }
    .btn{
      pointer-events:auto;
      cursor:pointer; user-select:none;
      padding:8px 12px; border-radius:12px;
      background:rgba(80,140,255,.16);
      border:1px solid rgba(140,190,255,.22);
    }
    .btn:hover{ background:rgba(80,140,255,.22); }

    
    .hudBtns{ display:flex; gap:10px; align-items:center; pointer-events:auto; }
    .hudBtns .btn{ display:inline-block; }
/* MENU */
    #menu{
      position:fixed; inset:0;
      display:grid; place-items:center;
      z-index:10;
      overflow:hidden;
      background:#000;
    }
    #menuVideo{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      opacity:1;
      filter:none;
      z-index:0;
      pointer-events:none;
    }
    #menuVignette{
      position:absolute; inset:0;
      background: radial-gradient(1100px 700px at 50% 40%, rgba(0,0,0,0.10), rgba(0,0,0,0.62));
      z-index:1;
      pointer-events:none;
    }
    #menuCard{
      position:relative;
      width:min(720px,92vw);
      border-radius:18px;
      padding:22px 18px 18px;
      background:rgba(10,16,34,.62);
      border:1px solid rgba(180,210,255,.14);
      backdrop-filter:blur(10px);
      box-shadow:0 20px 70px rgba(0,0,0,.45);
      text-align:center;
      z-index:2;
    }

    /* FLAG LOGO */
    #logoWrap{
      width:min(560px, 86vw);
      margin: 0 auto 12px;
      display:block;
      transform: perspective(900px) rotateX(3deg);
    }
    #logo{
      width:100%;
      height:auto;
      display:block;
      filter: url(#flagWave) drop-shadow(0 18px 40px rgba(0,0,0,.45));
      transform-origin:center;
      animation: logoSway 3.8s ease-in-out infinite;
      will-change: transform, filter;
    }
    @keyframes logoSway{
      0%   { transform: rotateZ(-0.8deg) translateY(0px); }
      50%  { transform: rotateZ(0.8deg) translateY(2px); }
      100% { transform: rotateZ(-0.8deg) translateY(0px); }
    }

    .menuBtn{
      width:100%;
      display:block;
      margin-top:10px;
      padding:12px 14px;
      border-radius:14px;
      font-weight:900;
      letter-spacing:.3px;
      cursor:pointer;
      border:1px solid rgba(140,190,255,.22);
      background:rgba(80,140,255,.16);
      color:#e6f0ff;
    }
    .menuBtn:hover{ background:rgba(80,140,255,.22); }
    .menuBtn.secondary{
      background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.10);
    }
    .menuBtn.secondary:hover{ background:rgba(255,255,255,0.12); }

    .menuBtn.primaryGold{
      background: linear-gradient(180deg, rgba(255,210,90,0.95), rgba(200,140,25,0.92));
      color: rgba(10,16,34,0.98);
      border:1px solid rgba(255,235,170,0.55);
      box-shadow: 0 12px 36px rgba(255,200,90,0.18);
    }
    .menuBtn.primaryGold:hover{ filter: brightness(1.05); }

    .subTitle{
      font-size:18px;
      font-weight:950;
      letter-spacing:.3px;
      margin: 2px 0 10px;
      text-align:center;
    }
    .subText{
      opacity:.9;
      line-height:1.5;
      font-size:14px;
      white-space:pre-wrap;
      background:rgba(0,0,0,0.15);
      border:1px solid rgba(180,210,255,.10);
      border-radius:14px;
      padding:12px 12px;
      min-height:170px;
      text-align:left;
    }
    .subText.centered{ text-align:center; }

    .tipLine{
      margin-top:12px;
      font-size:12px;
      opacity:.78;
    }

    /* ship select */
    .shipGrid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:12px;
      margin-top:12px;
    }
    @media (max-width: 720px){
  /* --- Fullscreen gameplay on mobile (no black bands) --- */
  #wrap{
    height:100svh;
    width:100vw;
    display:block;
  }
  canvas{
    width:100vw;
    height:100svh;
    max-width:none;
    max-height:none;
    border-radius:0;
  }

      .shipGrid{
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
      }
      .shipImg{ height: 86px; }
      .shipName{ font-size: 11px; }
      .shipMeta{ font-size: 11px; }
      #menuCard{ width: min(760px, 94vw); }
    }
    .shipCard{
      border-radius:14px;
      border:1px solid rgba(180,210,255,.12);
      background:rgba(255,255,255,0.06);
      padding:12px;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .shipCard:hover{
      transform: translateY(-2px);
      background:rgba(255,255,255,0.085);
      border-color: rgba(180,210,255,.18);
    }
    .shipCard.selected{
      background:rgba(80,140,255,.18);
      border-color: rgba(140,190,255,.28);
    }
    .shipImg{
      width:100%;
      height:120px;
      display:grid;
      place-items:center;
      background:rgba(0,0,0,0.12);
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.08);
      overflow:hidden;
    }
    .shipImg img{
      max-width:90%;
      max-height:90%;
      transform: rotate(0deg);
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
    }
    .shipName{
      margin-top:10px;
      font-weight:950;
      letter-spacing:.2px;
      font-size:13px;
    }
    .shipMeta{
      opacity:.85;
      font-size:12px;
      margin-top:4px;
      line-height:1.35;
    }

    /* footer */
    #footer{
      position:fixed;
      left:0; right:0; bottom:8px;
      text-align:center;
      font-size:12px;
      opacity:.82;
      z-index:11;
      pointer-events:auto;
      text-shadow: 0 2px 10px rgba(0,0,0,.45);
    }
    #footer a{
      color: rgba(230,245,255,0.92);
      text-decoration: none;
      border-bottom: 1px solid rgba(230,245,255,0.25);
    }
    #footer a:hover{
      border-bottom-color: rgba(230,245,255,0.55);
    }

    /* Post-race UI */
    #postUI{
      position:fixed;
      inset:0;
      display:none;
      place-items:center;
      z-index:12;
      background:rgba(0,0,0,0.35);
      backdrop-filter: blur(4px);
    }
    #postCard{
      width:min(680px,92vw);
      border-radius:18px;
      padding:18px 16px;
      background:rgba(10,16,34,.72);
      border:1px solid rgba(180,210,255,.16);
      box-shadow:0 20px 70px rgba(0,0,0,.55);
      text-align:center;
    }
    #postTitle{
      font-size:36px;
      font-weight:950;
      letter-spacing:.4px;
      margin:4px 0 10px;
    }
    #postStats{
      font-size:16px;
      opacity:.9;
      line-height:1.55;
      white-space:pre-wrap;
      background:rgba(0,0,0,0.16);
      border:1px solid rgba(180,210,255,.10);
      border-radius:14px;
      padding:12px 12px;
      margin:10px 0 12px;
    }

    /* Version tag (bottom-left) */
    #versionTag{
      position:fixed;
      left:10px; bottom:10px;
      z-index:20;
      font-size:12px;
      opacity:.72;
      background:rgba(10,16,34,.45);
      border:1px solid rgba(180,210,255,.10);
      border-radius:10px;
      padding:6px 9px;
      backdrop-filter: blur(8px);
      pointer-events:none;
    }

    /* Intro overlay */
    #introOverlay{
      position:fixed;
      inset:0;
      z-index:50;
      display:grid;
      place-items:center;
      background:#000;
      position:fixed;
      overflow:hidden;
    }
    #introVideo{
      width:100%;
      height:100%;
      object-fit:cover;
      position:absolute;
      inset:0;
      z-index:0;
    }
    /* Fallback overlay if autoplay blocked (still unskippable, just “start playback”) */
    #introTap{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      background:rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      color:#e6f0ff;
      text-align:center;
      padding:20px;
      z-index:2;
      pointer-events:auto;
    }
    #introTap .card{
      width:min(520px,92vw);
      border-radius:16px;
      padding:16px 14px;
      border:1px solid rgba(180,210,255,.16);
      background:rgba(10,16,34,.72);
      box-shadow:0 18px 60px rgba(0,0,0,.55);
    }
    #introTap .title{
      font-weight:950;
      font-size:18px;
      margin-bottom:8px;
    }
    #introTap .hint{
      opacity:.85;
      font-size:13px;
      line-height:1.45;
    }
    #introTap .btn2{
      margin-top:12px;
      display:inline-block;
      cursor:pointer;
      user-select:none;
      padding:10px 14px;
      border-radius:14px;
      font-weight:950;
      background: linear-gradient(180deg, rgba(255,210,90,0.95), rgba(200,140,25,0.92));
      color: rgba(10,16,34,0.98);
      border:1px solid rgba(255,235,170,0.55);
    }

/* ===== Mobile layout fixes ===== */
@media (max-width: 720px){
  #menu{
    height: 100svh;
  }
  #menuCard{
    max-height: calc(100svh - 90px);
    overflow: hidden;
  }
  #menuContent{
    max-height: calc(100svh - 240px);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    padding-right: 6px;
  }
  .menuBtn{
    padding: 11px 12px;
    border-radius: 14px;
  }
  .subText{
    max-height: 46svh;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
  #versionTag{
    bottom: 44px;
    left: 10px;
  }
  #logoWrap{
    width: min(420px, 86vw);
    margin-bottom: 8px;
  }
}
  
    /* ===== Touch controls (mobile) ===== */
    #touchControls{
      
      position:fixed;
      left:0; right:0;
      bottom:54px; /* deja sitio al footer */
      z-index:30;
      display:none;
      pointer-events:none;
      padding:10px 10px 12px;
    }
    #touchControls.hidden{ display:none !important; }
    #touchControls .row{
      display:flex;
      justify-content:space-between;
      gap:10px;
      pointer-events:auto;
    }
    #touchControls .cluster{
      display:flex;
      gap:10px;
      align-items:flex-end;
    }
    .tbtn{
      width:64px; height:64px;
      border-radius:18px;
      border:1px solid rgba(180,210,255,.18);
      background:rgba(10,16,34,.55);
      backdrop-filter: blur(10px);
      color:rgba(230,245,255,.95);
      font-weight:950;
      font-size:18px;
      display:grid;
      place-items:center;
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
      box-shadow:0 10px 28px rgba(0,0,0,.35);
    }
    .tbtn:active, .tbtn.down{
      background:rgba(120,190,255,.22);
      border-color:rgba(180,220,255,.28);
      transform: translateY(1px);
    }
    .tbtn.big{
      width:90px; height:64px;
      font-size:16px;
      letter-spacing:.2px;
    }
    .tbtn.gold{
      background: linear-gradient(180deg, rgba(255,210,90,0.92), rgba(200,140,25,0.88));
      border-color: rgba(255,235,170,0.55);
      color: rgba(10,16,34,0.98);
    }
    .tbtn.gold:active, .tbtn.gold.down{
      filter: brightness(1.03);
      transform: translateY(1px);
    }

    @media (pointer: coarse), (max-width: 720px){
      #touchControls{ display:block; }
      /* En mobile dejamos más aire abajo para controles */
      /* canvas sizing handled in mobile fixes */
    }

  
@media (max-width: 720px){
  /* Hide top bubbles on mobile, keep buttons */
  .hud .pill{ display:none; }
  .hud{ justify-content:flex-end; }
  .hudBtns{ flex-direction:column; align-items:flex-end; gap:8px; }
  .hudBtns .btn{ width:auto; padding:10px 12px; border-radius:14px; }

  /* Make game screen bigger while keeping aspect ratio */
  #wrap{ width:100vw; }
  canvas{
    width:100vw;
    height:auto;
    max-height: calc(100svh - 170px); /* header/buttons + touch controls + footer */
    border-radius: 12px;
  }

  /* Footer a bit smaller */
  #footer{ font-size:10px; bottom:6px; }

  /* Move version slightly down (but not overlapping footer) */
  #versionTag{ bottom: 28px; }
}

</style>
</head>
<body>
  <svg width="0" height="0" style="position:absolute">
    <filter id="flagWave">
      <feTurbulence type="fractalNoise" baseFrequency="0.012 0.020" numOctaves="2" seed="2" result="noise">
        <animate attributeName="baseFrequency" dur="4.0s"
                 values="0.012 0.020; 0.014 0.024; 0.012 0.020"
                 keyTimes="0;0.5;1" repeatCount="indefinite"/>
        <animate attributeName="seed" dur="6.5s"
                 values="2;3;2" keyTimes="0;0.5;1" repeatCount="indefinite"/>
      </feTurbulence>
      <feDisplacementMap in="SourceGraphic" in2="noise" scale="0" xChannelSelector="R" yChannelSelector="G">
        <animate attributeName="scale" dur="4.0s"
                 values="0; 18; 0" keyTimes="0;0.5;1" repeatCount="indefinite"/>
      </feDisplacementMap>
    </filter>
  </svg>

  <!-- INTRO (unskippable) -->
  <div id="introOverlay">
    <video id="introVideo" autoplay playsinline preload="auto">
      <source src="video/introvideo.webm" type="video/webm">
    </video>
    <div id="introTap">
      <div class="card">
        <div class="title">Iniciando vídeo de introducción…</div>
        <div class="hint">Si tu navegador bloquea el autoplay, pulsa el botón para comenzar. (No se puede omitir)</div>
        <div class="btn2" id="introStartBtn">INICIAR</div>
      </div>
    </div>
  </div>

  <div id="versionTag">v0.7</div>

  <div class="hud">
    <div class="pill"><b>Controls</b> — ↑ acel · ↓ freno (2s = reverse) · ←/→ girar · <b>Espacio</b> boost</div>
    <div class="pill" id="status">Cargando…</div>
    <div style="flex:1"></div>
    <div class="hudBtns">
      <div class="btn" id="restart">Reiniciar</div>
      <div class="btn" id="exitToMenu">MENU</div>
    </div>
  </div>

  <div id="menu" style="display:none;">
    <video id="menuVideo" autoplay loop muted playsinline>
      <source src="video/menu_bg_loop.webm" type="video/webm">
    </video>
    <div id="menuVignette"></div>

    <div id="menuCard">
      <div id="logoWrap">
        <img id="logo" src="imagen/logo1.png" alt="Logo" />
      </div>
      <div id="menuContent"></div>
    </div>
  </div>

  <div id="postUI">
    <div id="postCard">
      <div id="postTitle">RESULTADO</div>
      <div id="postStats"></div>
      <button class="menuBtn primaryGold" id="postMenuBtn">MENU PRINCIPAL</button>
    </div>
  </div>

  <div id="footer">© Disturbing Stories 2026 / Vianda Visual / <a href="https://www.disturbingstories.com" target="_blank" rel="noopener noreferrer">www.disturbingstories.com</a></div>

  <div id="touchControls" class="hidden" aria-label="Controles táctiles">
    <div class="row">
      <div class="cluster">
        <div class="tbtn" data-key="ArrowLeft">◀</div>
        <div class="tbtn" data-key="ArrowRight">▶</div>
      </div>
      <div class="cluster">
        <div class="tbtn big" data-key="ArrowDown">BRAKE</div>
        <div class="tbtn gold big" data-key="Space">BOOST</div>
      </div>
    </div>
  </div>


  <div id="wrap"><canvas id="c" width="1200" height="760"></canvas></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const statusEl = document.getElementById('status');
  const restartBtn = document.getElementById('restart');
  const exitToMenuBtn = document.getElementById('exitToMenu');

  const menuEl = document.getElementById('menu');
  const menuContent = document.getElementById('menuContent');
  const logoImg = document.getElementById('logo');
  const menuVideo = document.getElementById('menuVideo');

  // Mantén el video de fondo del menú reproduciéndose en mobile (al volver a la pestaña o si se pausa)
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
      if (menuEl.style.display !== "none") {
        menuVideo.play().catch(()=>{});
      }
    }
  });
  menuVideo.addEventListener("pause", () => {
    if (menuEl.style.display !== "none") {
      menuVideo.play().catch(()=>{});
    }
  });


  const postUI = document.getElementById('postUI');
  const postStats = document.getElementById('postStats');
  const postMenuBtn = document.getElementById('postMenuBtn');

  const versionTag = document.getElementById('versionTag');

  // Intro overlay
  const introOverlay = document.getElementById('introOverlay');
  const introVideo = document.getElementById('introVideo');
  const introTap = document.getElementById('introTap');
  const introStartBtn = document.getElementById('introStartBtn');

  // Hide version during intro
  versionTag.style.display = "none";

  async function tryPlayIntro(){
  // Always show the start overlay first (mobile browsers can "resolve" play() but still not start)
  introTap.style.display = "grid";

  try {
    introVideo.muted = false; // audio ON
    introVideo.volume = 1.0;
    await introVideo.play();
    // Don't hide here; wait for real playback signals (playing/timeupdate)
  } catch {
    // Autoplay with audio blocked => user must tap INICIAR
  }

  // Watchdog: if after a moment the video hasn't advanced, keep the overlay visible
  const t0 = introVideo.currentTime;
  setTimeout(() => {
    const stuck = introVideo.paused || introVideo.currentTime <= t0 + 0.001 || introVideo.readyState < 2;
    if (stuck) introTap.style.display = "grid";
  }, 500);
}

  introStartBtn.addEventListener("click", async ()=>{
    try{
      introVideo.muted = false;
      introVideo.volume = 1.0;
      await introVideo.play();
      // overlay will hide on 'playing'/'timeupdate'
    }catch{
      showIntroTap();
    }
  });


  // Cannot skip: block all keys during intro
  function blockKeysDuringIntro(e){
    if(introOverlay.style.display !== "none"){
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
  }
  window.addEventListener("keydown", blockKeysDuringIntro, {capture:true});
  window.addEventListener("keyup", blockKeysDuringIntro, {capture:true});

  // On intro end -> show menu + start menu music
  
  // Intro playback guards (hide the overlay ONLY when we detect real playback)
  function hideIntroTap(){
    introTap.style.display = "none";
  }
  function showIntroTap(){
    introTap.style.display = "grid";
  }

  introVideo.addEventListener("playing", hideIntroTap);
  introVideo.addEventListener("timeupdate", ()=>{
    if(introVideo.currentTime > 0.05) hideIntroTap();
  });
  introVideo.addEventListener("error", showIntroTap);
introVideo.addEventListener("ended", async ()=>{
    introOverlay.style.display = "none";
    versionTag.style.display = "block";
    await showMenu(); // will start menu music
  });

  // ---------- Assets ----------
  const meteorImg = new Image(); meteorImg.src = "imagen/meteorito1.png";
  const earthImg  = new Image(); earthImg.src  = "imagen/earth1.png";
  const aiShipImg = new Image(); aiShipImg.src = "imagen/nave1.png";

  const ship30Img = new Image(); ship30Img.src = "imagen/nave_30.png";
  const ship31Img = new Image(); ship31Img.src = "imagen/nave_31.png";
  const ship32Img = new Image(); ship32Img.src = "imagen/nave_32.png";

  const trackBaseImg  = new Image(); trackBaseImg.src  = "imagen/track_holo_base.png";
  const trackGlowImg  = new Image(); trackGlowImg.src  = "imagen/track_holo_glow.png";
  const trackDecalImg = new Image(); trackDecalImg.src = "imagen/track_decals.png";

  let meteorImgReady=false, earthImgReady=false, aiShipReady=false;
  let ship30Ready=false, ship31Ready=false, ship32Ready=false;
  let trackBaseReady=false, trackGlowReady=false, trackDecalReady=false;

  function updateLoadStatus(){
    const ok =
      meteorImgReady && earthImgReady &&
      aiShipReady && ship30Ready && ship31Ready && ship32Ready &&
      trackBaseReady && trackGlowReady && trackDecalReady;
    statusEl.textContent = ok ? "Listo" : "Cargando recursos…";
  }

  meteorImg.onload = () => { meteorImgReady=true; updateLoadStatus(); };
  earthImg.onload  = () => { earthImgReady=true; updateLoadStatus(); };
  aiShipImg.onload = () => { aiShipReady=true; updateLoadStatus(); };

  ship30Img.onload = () => { ship30Ready=true; updateLoadStatus(); };
  ship31Img.onload = () => { ship31Ready=true; updateLoadStatus(); };
  ship32Img.onload = () => { ship32Ready=true; updateLoadStatus(); };

  trackBaseImg.onload  = () => { trackBaseReady=true; updateLoadStatus(); rebuildPatterns(); };
  trackGlowImg.onload  = () => { trackGlowReady=true; updateLoadStatus(); rebuildPatterns(); };
  trackDecalImg.onload = () => { trackDecalReady=true; updateLoadStatus(); rebuildPatterns(); };

  logoImg.onerror = () => {
    const wrap = document.getElementById("logoWrap");
    wrap.innerHTML = `<div style="font-weight:950;font-size:30px;letter-spacing:.6px;margin-bottom:8px">ICARUS RACERS</div>`;
  };

  // ---------- Audio ----------
  const menuMusic = new Audio("music/music2.mp3");
  menuMusic.loop = true;
  menuMusic.volume = 0.4125;

  const raceMusic = new Audio("music/music1.mp3");
  raceMusic.loop = true;
  raceMusic.volume = 0.45;

  const introNarr = new Audio("music/intro2.mp3");
  introNarr.loop = false;
  introNarr.volume = 0.85;

  const ohno = new Audio("music/ohno.mp3");
  ohno.loop = false;
  ohno.volume = 0.95;

  async function playMenuMusic(){ try{ await menuMusic.play(); }catch{} }
  function stopMenuMusic(){ try{ menuMusic.pause(); menuMusic.currentTime=0; }catch{} }
  async function playRaceMusic(){ try{ await raceMusic.play(); }catch{} }
  function stopRaceMusic(){ try{ raceMusic.pause(); raceMusic.currentTime=0; }catch{} }
  function stopIntroNarr(){ try{ introNarr.pause(); introNarr.currentTime=0; }catch{} }
  async function playIntroNarr(){ stopIntroNarr(); try{ await introNarr.play(); }catch{} }
  function playOhNo(){ try{ ohno.currentTime=0; ohno.play().catch(()=>{});}catch{} }

  // Ship audio layers
  const shipAudio = {
    enabled: true,
    idle:     new Audio("music/engine_idle_loop.mp3"),
    throttle: new Audio("music/engine_throttle_loop.mp3"),
    boost:    new Audio("music/engine_boost_loop.mp3"),
    brake:    new Audio("music/engine_brake_loop.mp3"),
    start:    new Audio("music/engine_start_one_shot.mp3"),
    hit:      new Audio("music/engine_hit_one_shot.mp3"),
    vIdle:0, vThrottle:0, vBoost:0, vBrake:0,
    started:false,
    startPlayed:false,
    hitCD:0
  };
  function initShipAudio(){
    for (const a of [shipAudio.idle, shipAudio.throttle, shipAudio.boost, shipAudio.brake]){
      a.loop = true;
      a.volume = 0.0;
      a.preload = "auto";
    }
    shipAudio.start.loop = false;
    shipAudio.hit.loop = false;
    shipAudio.start.volume = 0.85;
    shipAudio.hit.volume = 0.85;
  }
  initShipAudio();

  async function startShipAudioLoops(){
    if(!shipAudio.enabled) return;
    if(shipAudio.started) return;
    shipAudio.started = true;
    const loops=[shipAudio.idle, shipAudio.throttle, shipAudio.boost, shipAudio.brake];
    for (const a of loops){
      try{ a.currentTime=0; await a.play(); }catch{}
    }
  }
  function stopShipAudioAll(){
    const all=[shipAudio.idle, shipAudio.throttle, shipAudio.boost, shipAudio.brake, shipAudio.start, shipAudio.hit];
    for (const a of all){
      try{ a.pause(); a.currentTime = 0; }catch{}
    }
    shipAudio.started=false;
    shipAudio.startPlayed=false;
    shipAudio.vIdle=shipAudio.vThrottle=shipAudio.vBoost=shipAudio.vBrake=0;
  }
  function playShipStartOnce(){
    if(!shipAudio.enabled) return;
    if(shipAudio.startPlayed) return;
    shipAudio.startPlayed = true;
    try{ shipAudio.start.currentTime = 0; shipAudio.start.play().catch(()=>{}); }catch{}
  }
  function playShipHit(){
    if(!shipAudio.enabled) return;
    if(shipAudio.hitCD > 0) return;
    shipAudio.hitCD = 0.18;
    try{ shipAudio.hit.currentTime = 0; shipAudio.hit.play().catch(()=>{}); }catch{}
  }

  // ---------- WebAudio SFX ----------
  let audioCtx=null, masterGain=null;
  function ensureSfxAudio(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.9;
      masterGain.connect(audioCtx.destination);
    }
    if(audioCtx.state==="suspended") audioCtx.resume().catch(()=>{});
  }
  function playOneShot({type="sine", freq=440, dur=0.12, gain=0.12, freq2=null}){
    try{
      ensureSfxAudio();
      const t0=audioCtx.currentTime;
      const o=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      o.type=type;
      o.frequency.setValueAtTime(freq, t0);
      if(freq2) o.frequency.exponentialRampToValueAtTime(freq2, t0 + dur*0.9);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g).connect(masterGain);
      o.start(t0); o.stop(t0 + dur + 0.02);
    }catch{}
  }
  function playNoiseBurst({dur=0.18, gain=0.14, hp=900}){
    try{
      ensureSfxAudio();
      const t0=audioCtx.currentTime;
      const len=Math.floor(audioCtx.sampleRate * dur);
      const buf=audioCtx.createBuffer(1,len,audioCtx.sampleRate);
      const data=buf.getChannelData(0);
      for(let i=0;i<len;i++) data[i]=(Math.random()*2-1)*(1-i/len);
      const src=audioCtx.createBufferSource();
      src.buffer=buf;

      const f=audioCtx.createBiquadFilter();
      f.type="highpass";
      f.frequency.setValueAtTime(hp,t0);

      const g=audioCtx.createGain();
      g.gain.setValueAtTime(0.0001,t0);
      g.gain.exponentialRampToValueAtTime(gain,t0+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001,t0+dur);

      src.connect(f).connect(g).connect(masterGain);
      src.start(t0); src.stop(t0+dur+0.02);
    }catch{}
  }
  function beepCheckpoint(){ playOneShot({type:"sine", freq:740, freq2:980, dur:0.13, gain:0.12}); }
  function sfxAsteroidBreak(){ playNoiseBurst({dur:0.20, gain:0.18, hp:700}); playOneShot({type:"square", freq:220, freq2:90, dur:0.16, gain:0.10}); }
  function sfxImpact(){ playNoiseBurst({dur:0.12, gain:0.10, hp:1000}); }

  // ---------- Utils ----------
  const TAU = Math.PI*2;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rand=(a,b)=>a+Math.random()*(b-a);
  const hypot=Math.hypot;
  const dist2=(ax,ay,bx,by)=>(ax-bx)**2+(ay-by)**2;
  const normAng=(a)=>{ while(a>Math.PI)a-=TAU; while(a<-Math.PI)a+=TAU; return a; };

  function pointSegClosest(px,py, ax,ay, bx,by){
    const abx=bx-ax, aby=by-ay;
    const apx=px-ax, apy=py-ay;
    const ab2=abx*abx+aby*aby || 1e-9;
    let t=(apx*abx + apy*aby)/ab2;
    t=clamp(t,0,1);
    const cx=ax+abx*t, cy=ay+aby*t;
    return { d2: dist2(px,py,cx,cy), t, cx, cy };
  }

  // ---------- Input ----------
  const keys=new Set();
  const isMobile = window.matchMedia && (window.matchMedia("(pointer: coarse)").matches || window.matchMedia("(max-width: 720px)").matches);

  window.addEventListener("keydown",(e)=>{
    // intro blocks everything
    if(introOverlay.style.display !== "none") return;
    keys.add(e.code);
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
  },{passive:false});
  window.addEventListener("keyup",(e)=>{
    if(introOverlay.style.display !== "none") return;
    keys.delete(e.code);
  });

  
  // ---------- Touch controls (mobile) ----------
  const touchControlsEl = document.getElementById("touchControls");

  function setKey(code, isDown){
    if(isDown) keys.add(code);
    else keys.delete(code);
  }

  function bindTouchButton(btn){
    const code = btn.dataset.key;
    const down = () => { setKey(code, true); btn.classList.add("down"); };
    const up = () => { setKey(code, false); btn.classList.remove("down"); };

    // Pointer events cover touch + pen
    btn.addEventListener("pointerdown", (e)=>{
      if(introOverlay.style.display !== "none") return;
      e.preventDefault();
      btn.setPointerCapture?.(e.pointerId);
      down();
    }, {passive:false});

    btn.addEventListener("pointerup", (e)=>{ e.preventDefault(); up(); }, {passive:false});
    btn.addEventListener("pointercancel", (e)=>{ e.preventDefault(); up(); }, {passive:false});
    btn.addEventListener("pointerleave", ()=> up());
  }

  if(touchControlsEl){
    touchControlsEl.querySelectorAll(".tbtn").forEach(bindTouchButton);
  }
// ---------- Track ----------
  const RUNOFF_LEN = 2600;
  const TRACK_W = 360;
  const WALL_BOUNCE = 0.08;
  const WALL_TANGENTIAL_LOSS = 0.03;

  function generateMainPoints(){
    const pts=[];
    const N=34;
    const step=1400;
    const startY=1700;
    for(let i=0;i<N;i++){
      const y=startY - i*step;
      const x =
        300*Math.sin(i*0.30) +
        180*Math.sin(i*0.14 + 1.1) +
         95*Math.sin(i*0.62 + 0.3);
      pts.push({x,y});
    }
    pts[0].x=0; pts[0].y=startY;
    pts[1].x=36;

    const last=pts[pts.length-1];
    const prev=pts[pts.length-2];
    const dx=last.x-prev.x, dy=last.y-prev.y;
    const len=Math.hypot(dx,dy)||1;
    const ux=dx/len, uy=dy/len;
    pts.push({x:last.x+ux*(RUNOFF_LEN*0.55), y:last.y+uy*(RUNOFF_LEN*0.55)});
    pts.push({x:last.x+ux*(RUNOFF_LEN*1.00), y:last.y+uy*(RUNOFF_LEN*1.00)});
    return pts;
  }

  function buildPolyline(points){
    const cum=[0];
    let total=0;
    for(let i=0;i<points.length-1;i++){
      const a=points[i], b=points[i+1];
      total += hypot(b.x-a.x,b.y-a.y);
      cum.push(total);
    }
    return {points,cum,total};
  }

  const main = buildPolyline(generateMainPoints());
  const finishS = Math.max(0, main.total - RUNOFF_LEN);

  function sampleAt(poly,s){
    s=clamp(s,0,poly.total);
    let lo=0, hi=poly.cum.length-1;
    while(lo<hi){
      const mid=(lo+hi)>>1;
      if(poly.cum[mid] < s) lo=mid+1;
      else hi=mid;
    }
    const idx=Math.max(1,lo)-1;
    const a=poly.points[idx], b=poly.points[idx+1];
    const segLen=hypot(b.x-a.x,b.y-a.y)||1e-6;
    const t=(s-poly.cum[idx])/segLen;
    const x=lerp(a.x,b.x,t), y=lerp(a.y,b.y,t);
    const ux=(b.x-a.x)/segLen, uy=(b.y-a.y)/segLen;
    const nx=-uy, ny=ux;
    return {x,y,ux,uy,nx,ny,idx,t};
  }

  function nearestOnPolyline(poly, px, py){
    let best=null;
    for(let i=0;i<poly.points.length-1;i++){
      const a=poly.points[i], b=poly.points[i+1];
      const dx=b.x-a.x, dy=b.y-a.y;
      const len2=dx*dx+dy*dy || 1e-9;
      let t=((px-a.x)*dx + (py-a.y)*dy)/len2;
      t=clamp(t,0,1);
      const nx=a.x+dx*t, ny=a.y+dy*t;
      const d2=dist2(px,py,nx,ny);
      if(!best || d2<best.d2){
        const len=Math.sqrt(len2);
        const ux=dx/len, uy=dy/len;
        const lx=-uy, ly=ux;
        const side=((px-nx)*lx + (py-ny)*ly);
        const s=poly.cum[i] + len*t;
        best={d2,x:nx,y:ny,ux,uy,lx,ly,side,s};
      }
    }
    return best;
  }

  // branches (kept)
  const branches = [];
  const branchDefs = [
    { s0: 9000,  s1: 15500, maxOff: 220 },
    { s0: 24000, s1: 30500, maxOff: -240 },
    { s0: 35500, s1: 42000, maxOff: 200 },
  ];
  function buildBranch(def){
    const pts=[], mapS=[];
    const step=40;
    for(let s=def.s0; s<=def.s1; s+=step){
      const p=sampleAt(main,s);
      const u=(s-def.s0)/Math.max(1,(def.s1-def.s0));
      const w=Math.sin(u*Math.PI);
      const off=def.maxOff*w;
      pts.push({x:p.x+p.nx*off,y:p.y+p.ny*off});
      mapS.push(s);
    }
    const poly=buildPolyline(pts);
    poly.mapS=mapS;
    return poly;
  }
  for(const d of branchDefs){
    if(d.s0 < finishS - 800 && d.s1 < finishS - 200) branches.push(buildBranch(d));
  }
  function branchMainSAt(branch, sOnBranch){
    const frac=clamp(sOnBranch/Math.max(1e-6,branch.total),0,1);
    const idxF=frac*(branch.mapS.length-1);
    const i0=Math.floor(idxF);
    const i1=Math.min(branch.mapS.length-1,i0+1);
    const t=idxF-i0;
    return lerp(branch.mapS[i0], branch.mapS[i1], t);
  }
  function nearestOnTrack(px, py){
    const m=nearestOnPolyline(main,px,py);
    let best={hit:m, prog:m.s, ref:main};
    for(const br of branches){
      const h=nearestOnPolyline(br,px,py);
      const sMain=branchMainSAt(br,h.s);
      if(h.d2 < best.hit.d2) best={hit:h, prog:sMain, ref:br};
    }
    return best;
  }

  // ---------- Checkpoints ----------
  const NUM_CPS=25;
  const checkpoints=[];
  for(let i=1;i<=NUM_CPS;i++){
    const s=(i/(NUM_CPS+1))*finishS;
    const p=sampleAt(main,s);
    checkpoints.push({i:i-1, s, x:p.x, y:p.y, nx:p.nx, ny:p.ny});
  }

  const startLine=(()=>{ const p=sampleAt(main,30); return {x:p.x,y:p.y,nx:1,ny:0,s:0}; })();
  const finishLine=(()=>{ const p=sampleAt(main,finishS); return {x:p.x,y:p.y,nx:1,ny:0,s:finishS}; })();

  // ---------- State ----------
  let gameState="menu"; // menu | race | post | destroyed
  let raceTime=0;
  let countdown=0;
  let raceStarted=false;
  let postPlace=0;
  let bestKmh=0;

  // ---------- Earth scroll ----------
  const ships=[];
  const camera={x:0,y:0,zoom:1};

  function drawEarthScroll(){
    if(!earthImgReady) return;
    const scale = canvas.width / earthImg.width;
    const h = earthImg.height * scale;

    const me = ships[0];
    const prog01 = me ? clamp(me.maxProgress / Math.max(1, finishS), 0, 1) : 0;

    const yStart = canvas.height - h;
    const yEnd = 0;
    const yProg = lerp(yStart, yEnd, prog01);
    const camParY = -(camera.y - startLine.y) * 0.08 * camera.zoom;

    const yFinal = clamp(yProg + camParY, yStart, yEnd);
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.drawImage(earthImg, 0, yFinal, canvas.width, h);
    ctx.restore();
  }

  // ---------- Depth dots ----------
  const depthDots=[];
  function initDepthDots(){
    depthDots.length=0;
    const count=420;
    const yTop = sampleAt(main, finishS).y - 2200;
    const yBottom = startLine.y + 2200;
    for(let i=0;i<count;i++){
      depthDots.push({
        x: rand(-2400, 2400),
        y: rand(yTop, yBottom),
        r: rand(0.8, 2.4),
        a: rand(0.08, 0.28),
        par: rand(0.12, 0.28),
        drift: rand(-14, 14)
      });
    }
  }
  function drawDepthDots(dt){
    const z=camera.zoom;
    ctx.save();
    for(const d of depthDots){
      d.y += d.drift * dt;
      const sx = (d.x - camera.x*d.par)*z + canvas.width/2;
      const sy = (d.y - camera.y*d.par)*z + canvas.height/2;
      if(sx<-20||sx>canvas.width+20||sy<-20||sy>canvas.height+20) continue;
      ctx.globalAlpha = d.a;
      ctx.fillStyle = "rgba(230,245,255,1)";
      ctx.beginPath();
      ctx.arc(sx, sy, d.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // ---------- Track patterns ----------
  let patBase=null, patGlow=null, patDecal=null;
  function rebuildPatterns(){
    try{
      if(trackBaseReady)  patBase  = ctx.createPattern(trackBaseImg,  "repeat");
      if(trackGlowReady)  patGlow  = ctx.createPattern(trackGlowImg,  "repeat");
      if(trackDecalReady) patDecal = ctx.createPattern(trackDecalImg, "repeat");
    }catch{}
  }
  function setPatternWorldTransform(pat, img, extraScrollPx){
    if(!pat || !pat.setTransform || !img || !img.width) return false;
    const z = camera.zoom;
    const tileScale = z * 0.85;
    const tx = (-camera.x * z) + canvas.width/2;
    const ty = (-camera.y * z) + canvas.height/2 + extraScrollPx;
    const m = new DOMMatrix();
    m.translateSelf(tx, ty);
    m.scaleSelf(tileScale, tileScale);
    pat.setTransform(m);
    return true;
  }

  function worldToScreen(wx,wy){
    const z=camera.zoom;
    return { x:(wx-camera.x)*z + canvas.width/2, y:(wy-camera.y)*z + canvas.height/2 };
  }

  // ---------- Drawing helpers ----------
  const TAU2 = Math.PI*2;
  function drawStars(){
    ctx.save();
    ctx.globalAlpha=0.88;
    for(let i=0;i<180;i++){
      const px=(i*997)%8192;
      const py=(i*613)%8192;
      const wx=px-4096;
      const wy=py-4096;
      const par=0.03;
      const z=camera.zoom;
      const sx=(wx-camera.x*par)*z + canvas.width/2;
      const sy=(wy-camera.y*par)*z + canvas.height/2;
      const r=(i%7===0)?1.6:1.0;
      if(sx<-12||sx>canvas.width+12||sy<-12||sy>canvas.height+12) continue;
      ctx.fillStyle="rgba(220,235,255,0.75)";
      ctx.beginPath(); ctx.arc(sx,sy,r,0,TAU2); ctx.fill();
    }
    ctx.restore();
  }

  function drawTrackTextured(poly, bodyAlpha){
    const havePat = patBase && patGlow && patDecal && trackBaseReady && trackGlowReady && trackDecalReady;

    ctx.save();
    ctx.lineCap="round"; ctx.lineJoin="round";
    ctx.strokeStyle=`rgba(120,170,255,0.16)`;
    ctx.lineWidth=TRACK_W+34;
    ctx.beginPath();
    for(let i=0;i<poly.points.length;i++){
      const p=worldToScreen(poly.points[i].x, poly.points[i].y);
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.lineCap="round"; ctx.lineJoin="round";
    ctx.lineWidth=TRACK_W;
    ctx.beginPath();
    for(let i=0;i<poly.points.length;i++){
      const p=worldToScreen(poly.points[i].x, poly.points[i].y);
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    if(havePat && patBase.setTransform){
      const drift = (raceTime * 120) * camera.zoom;
      setPatternWorldTransform(patBase, trackBaseImg, drift);
      ctx.globalAlpha = bodyAlpha;
      ctx.strokeStyle = patBase;
      ctx.stroke();
    } else {
      ctx.globalAlpha = bodyAlpha;
      ctx.strokeStyle="rgba(20,28,58,0.88)";
      ctx.stroke();
    }
    ctx.restore();

    if(havePat && patGlow.setTransform && patDecal.setTransform){
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.lineCap="round"; ctx.lineJoin="round";
      ctx.lineWidth=TRACK_W;
      ctx.beginPath();
      for(let i=0;i<poly.points.length;i++){
        const p=worldToScreen(poly.points[i].x, poly.points[i].y);
        if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
      }
      const driftG = (raceTime * 220) * camera.zoom;
      setPatternWorldTransform(patGlow, trackGlowImg, driftG);
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = patGlow;
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.lineCap="round"; ctx.lineJoin="round";
      ctx.lineWidth = TRACK_W*0.70;
      ctx.beginPath();
      for(let i=0;i<poly.points.length;i++){
        const p=worldToScreen(poly.points[i].x, poly.points[i].y);
        if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
      }
      const driftD = (raceTime * 320) * camera.zoom;
      setPatternWorldTransform(patDecal, trackDecalImg, driftD);
      ctx.globalAlpha = 0.40;
      ctx.strokeStyle = patDecal;
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawLine(line,color,width){
    const a=worldToScreen(line.x - (TRACK_W*0.52), line.y);
    const b=worldToScreen(line.x + (TRACK_W*0.52), line.y);
    ctx.save();
    ctx.globalAlpha=0.92;
    ctx.strokeStyle=color;
    ctx.lineWidth=width;
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    ctx.restore();
  }
  function drawStartFinish(){
    drawLine(startLine,"rgba(160,255,200,0.85)",5);
    drawLine(finishLine,"rgba(255,220,140,0.88)",6);
  }

  function drawCheckpoints(){
    ctx.save();
    for(const cp of checkpoints){
      const a=worldToScreen(cp.x + cp.nx*(TRACK_W*0.48), cp.y + cp.ny*(TRACK_W*0.48));
      const b=worldToScreen(cp.x - cp.nx*(TRACK_W*0.48), cp.y - cp.ny*(TRACK_W*0.48));
      ctx.globalAlpha=0.12;
      ctx.strokeStyle="rgba(210,230,255,0.95)";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.restore();
  }

  // ---------- Meteorites ----------
  const meteorites=[];
  const meteorShards=[];
  const BIN_SIZE=760;
  let safeCorridor=[];

  function buildSafeCorridor(){
    safeCorridor=[];
    const bins=Math.ceil(finishS / BIN_SIZE);
    const half=TRACK_W*0.5;
    const margin=56;
    for(let i=0;i<bins;i++){
      const t=i/Math.max(1,bins-1);
      const base=0.65*Math.sin(t*TAU*1.00) + 0.35*Math.sin(t*TAU*2.05 + 1.1);
      const x=base*(half-margin-14);
      safeCorridor.push(clamp(x, -(half-margin), (half-margin)));
    }
  }
  function generateMeteorites(){
    meteorites.length=0;
    meteorShards.length=0;
    buildSafeCorridor();

    const count=92;
    const marginS=2100;
    const half=TRACK_W*0.5;
    const rMin=11, rMax=19;
    const safeRadius=62;

    const bins=Math.ceil(finishS/BIN_SIZE);
    const binCounts=new Array(bins).fill(0);

    let tries=0;
    while(meteorites.length<count && tries<count*70){
      tries++;
      const s=rand(marginS, finishS-900);
      const bin=clamp(Math.floor(s/BIN_SIZE),0,bins-1);
      if(binCounts[bin]>=3) continue;

      const p=sampleAt(main,s);
      const lateral=rand(-(half-44),(half-44));
      const safeX=safeCorridor[bin] ?? 0;
      if(Math.abs(lateral-safeX) < safeRadius) continue;

      const x=p.x + p.nx*lateral;
      const y=p.y + p.ny*lateral;
      const r=rand(rMin,rMax);

      let ok=true;
      for(const m of meteorites){
        if(dist2(x,y,m.x,m.y) < (r+m.r+26)**2){ ok=false; break; }
      }
      if(!ok) continue;

      meteorites.push({ x,y,r, alive:true, solidCooldown:0, hp:3, ang:rand(0,TAU), angVel:rand(-0.22,0.22) });
      binCounts[bin]++;
    }
  }

  function spawnMeteorShards(mx,my,mr, ship){
    if(!meteorImgReady) return;
    const pieces=12 + Math.floor(Math.random()*6);
    const baseAng=Math.atan2(ship.vy, ship.vx);
    for(let i=0;i<pieces;i++){
      const size=rand(mr*0.55, mr*1.05);
      const sx=rand(0,0.70)*meteorImg.width;
      const sy=rand(0,0.70)*meteorImg.height;
      const sw=rand(0.18,0.36)*meteorImg.width;
      const sh=rand(0.18,0.36)*meteorImg.height;
      const a=baseAng + rand(-1.25,1.25);
      const sp=rand(260,650);
      meteorShards.push({
        x:mx+rand(-8,8), y:my+rand(-8,8),
        vx:Math.cos(a)*sp + ship.vx*0.25,
        vy:Math.sin(a)*sp + ship.vy*0.25,
        ang:rand(0,TAU), angVel:rand(-3.3,3.3)*0.35,
        life:rand(0.35,0.85),
        size, sx,sy,sw,sh
      });
    }
  }
  function updateMeteorites(dt){
    for(let i=meteorites.length-1;i>=0;i--){
      const m=meteorites[i];
      if(!m.alive){ meteorites.splice(i,1); continue; }
      m.solidCooldown=Math.max(0,m.solidCooldown-dt);
      m.ang += m.angVel*dt;
    }
    for(let i=meteorShards.length-1;i>=0;i--){
      const s=meteorShards[i];
      s.life -= dt;
      s.x += s.vx*dt; s.y += s.vy*dt;
      s.vx *= Math.pow(0.04, dt);
      s.vy *= Math.pow(0.04, dt);
      s.ang += s.angVel*dt;
      if(s.life<=0) meteorShards.splice(i,1);
    }
  }

  function drawMeteorites(){
    for(const m of meteorites){
      if(!m.alive) continue;
      const p=worldToScreen(m.x,m.y);
      ctx.save();
      ctx.translate(p.x,p.y);
      ctx.rotate(m.ang);
      const w=(m.r*2)*camera.zoom;
      const h=(m.r*2)*camera.zoom;
      ctx.globalAlpha=0.95;
      if(meteorImgReady) ctx.drawImage(meteorImg,-w/2,-h/2,w,h);
      ctx.restore();
    }
  }
  function drawMeteorShards(){
    if(!meteorImgReady) return;
    ctx.save();
    for(const s of meteorShards){
      const p=worldToScreen(s.x,s.y);
      const alpha=clamp(s.life/0.25,0,1);
      ctx.globalAlpha=0.85*alpha;
      ctx.save();
      ctx.translate(p.x,p.y);
      ctx.rotate(s.ang);
      const w=s.size*camera.zoom;
      const h=s.size*camera.zoom;
      ctx.drawImage(meteorImg, s.sx,s.sy,s.sw,s.sh, -w/2,-h/2,w,h);
      ctx.restore();
    }
    ctx.restore();
  }

  // ---------- FX ----------
  const particles=[];
  const speedLines=[];
  function spawnHitSparks(x,y,n=22){
    for(let i=0;i<n;i++){
      particles.push({ x:x+rand(-7,7), y:y+rand(-7,7), vx:rand(-520,520), vy:rand(-520,520), life:rand(0.10,0.32), r:rand(1.0,3.0), c:"rgba(230,245,255,0.95)" });
    }
  }
  function spawnExplosion(ship, scale=1){
    const mult = scale;
    spawnHitSparks(ship.x, ship.y, Math.floor(90*mult));
    for(let i=0;i<Math.floor(60*mult);i++){
      particles.push({
        x:ship.x+rand(-10*mult,10*mult),
        y:ship.y+rand(-10*mult,10*mult),
        vx:rand(-700,700)*mult,
        vy:rand(-700,700)*mult,
        life:rand(0.12,0.55),
        r:rand(1.0,3.6)*mult,
        c:"rgba(180,240,255,0.9)"
      });
    }
  }
  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.life -= dt;
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx *= Math.pow(0.001, dt);
      p.vy *= Math.pow(0.001, dt);
      p.r  *= Math.pow(0.05, dt);
      if(p.life<=0 || p.r<0.2) particles.splice(i,1);
    }
    for(let i=speedLines.length-1;i>=0;i--){
      const s=speedLines[i];
      s.life -= dt;
      s.y += s.vy*dt;
      if(s.life<=0) speedLines.splice(i,1);
    }
  }
  function updateSpeedLines(dt, boostIntensity){
    if(boostIntensity>0.05){
      const add=Math.floor(75*boostIntensity*dt*60);
      for(let i=0;i<add;i++){
        speedLines.push({ x:rand(0,canvas.width), y:rand(0,canvas.height), vy:rand(700,1750)*(0.85+boostIntensity), life:rand(0.07,0.16), len:rand(18,62)*(0.85+boostIntensity) });
      }
    }
  }
  function drawSpeedLinesOverlay(){
    ctx.save();
    ctx.strokeStyle="rgba(230,245,255,0.85)";
    ctx.lineWidth=2;
    for(const s of speedLines){
      ctx.globalAlpha=clamp(s.life*7,0,0.75);
      ctx.beginPath();
      ctx.moveTo(s.x,s.y);
      ctx.lineTo(s.x, s.y - s.len);
      ctx.stroke();
    }
    ctx.restore();
  }

  // ---------- Ships ----------
  const MAX_HITS=10;
  const SHIP_WORLD_W = TRACK_W * 0.20;

  // FÍSICAS “como antes”: radio un pelín más grande + resolución visible.
  function shipCollisionRadius(){ return SHIP_WORLD_W * 0.30; }

  const shipDefs = [
    { id:"30", img: ship30Img, ready:()=>ship30Ready, label:"ICARUS 3.0 - 3/0", blurb:"Gira muy bien",
      tune:(s)=>{ s.turnRate *= 1.22; s.drift *= 0.90; } },
    { id:"31", img: ship31Img, ready:()=>ship31Ready, label:"ICARUS 3.1 - JM/S", blurb:"Frena mejor",
      tune:(s)=>{ s.brakePower *= 1.35; } },
    { id:"32", img: ship32Img, ready:()=>ship32Ready, label:"ICARUS 3.2 - X/S", blurb:"BOOST más rápido",
      tune:(s)=>{ s.boostMax *= 1.18; s.boostAccelMul *= 1.18; } },
  ];
  let selectedShipId = "31";

  function makeShip(opts){
    return {
      name:opts.name,
      x:opts.x, y:opts.y, ang:opts.ang,
      vx:0, vy:0,
      px: opts.x, py: opts.y,
      isAI:!!opts.isAI,

      accel: opts.accel ?? 1180,
      turnRate: opts.turnRate ?? 3.55,
      drift: opts.drift ?? 0.19,

      baseMax: opts.baseMax ?? 980,
      boostMax: opts.boostMax ?? 1780,
      boostAccelMul: opts.boostAccelMul ?? 2.25,

      brakePower: opts.brakePower ?? 1.0,

      thrust:0, steer:0, brake:0, boost:0, reverse:0,
      cpIndex:0, finished:false, finishTime:null,
      progress:0, maxProgress:0, place:0,
      boostEnergy: opts.boostEnergy ?? 1.0,
      downHold:0,

      hits:0, hitCD:0,
      destroyed:false,

      sprite: opts.sprite || aiShipImg,
      spriteReady: opts.spriteReady || aiShipReady,

      ai:{ skill: opts.aiSkill ?? 0.86 },
    };
  }

  function destroyShip(ship){
    if(ship.destroyed) return;
    ship.destroyed = true;

    spawnExplosion(ship, ship === ships[0] ? 10 : 1);
    if(ship === ships[0]) playOhNo();

    if(ship === ships[0]){
      gameState="destroyed";
      shipAudio.vIdle=shipAudio.vThrottle=shipAudio.vBoost=shipAudio.vBrake=0;
    }
  }
  function applyHit(ship, amount=1){
    if(ship.destroyed) return;
    if(ship.hitCD > 0) return;
    ship.hits += amount;
    ship.hitCD = 0.22;
    playShipHit();
    if(ship.hits >= MAX_HITS) destroyShip(ship);
  }

  // ---------- Boost ----------
  const BOOST_DRAIN_PER_SEC = 0.40;
  const BOOST_GAIN_PER_BREAK = 0.18;
  const BOOST_GAIN_PER_CP = 0.07;
  function awardBoostEnergy(ship, amount){ ship.boostEnergy = clamp(ship.boostEnergy + amount, 0, 1); }

  // ---------- Player controls ----------
  function handlePlayer(ship, dt){
    // Mobile: auto-accelerate (no ACCEL button)
    ship.thrust = (isMobile && raceStarted && !ship.finished) ? 1 : (keys.has("ArrowUp") ? 1 : 0);
    const down = keys.has("ArrowDown");
    if(down) ship.downHold += dt;
    else ship.downHold = 0;
    ship.brake = down ? 1 : 0;
    ship.reverse = (ship.downHold >= 2.0 && !keys.has("ArrowUp")) ? 1 : 0;
    ship.steer = (keys.has("ArrowRight") ? 1 : 0) - (keys.has("ArrowLeft") ? 1 : 0);
    ship.boost = (keys.has("Space") && ship.boostEnergy > 0.01 && !ship.reverse) ? 1 : 0;
    if(isMobile && ship.brake && !ship.reverse) ship.thrust = 0;
  }

  // ---------- AI ----------
  function handleAI(ship, dt){
    const my=nearestOnTrack(ship.x, ship.y);
    ship.progress=my.prog;
    ship.maxProgress=Math.max(ship.maxProgress, ship.progress);

    let targetS = ship.progress + 430;
    const nextCp = checkpoints[ship.cpIndex] ?? null;
    if(nextCp && ship.maxProgress < nextCp.s - 120) targetS = nextCp.s;

    const tp=sampleAt(main,targetS);
    const desired=Math.atan2(tp.y-ship.y, tp.x-ship.x);
    let angErr=normAng(desired-ship.ang);

    ship.steer = clamp(angErr*1.45, -1, 1);
    ship.thrust = 1;
    ship.brake = 0;
    ship.reverse = 0;

    const speed=hypot(ship.vx,ship.vy);
    if(Math.abs(angErr) > 0.75 && speed > 980) ship.brake=1;

    ship.boost = (ship.boostEnergy>0.02 && Math.abs(angErr)<0.18 && speed>650 && Math.random()<0.02) ? 1 : 0;
  }

  // ---------- Camera ----------
  function updateCamera(dt){
    const me=ships[0];
    if(!me) return;

    const sp=hypot(me.vx,me.vy);
    const boost=me.boost?1:0;

    const baseZoomFar=0.72;
    const boostZoomFar=0.66;
    const speedFactor=clamp(sp/1750,0,1);
    const targetZoom = lerp(baseZoomFar + 0.05, baseZoomFar, speedFactor) * (boost ? (boostZoomFar/baseZoomFar) : 1);
    camera.zoom = lerp(camera.zoom, targetZoom, 1 - Math.pow(0.001, dt));

    // Player lower on screen
    const screenOffsetPx = 160;
    const worldOffset = screenOffsetPx / Math.max(0.001, camera.zoom);

    camera.x = lerp(camera.x, me.x, 1 - Math.pow(0.001, dt));
    camera.y = lerp(camera.y, me.y - worldOffset, 1 - Math.pow(0.001, dt));
  }

  // ---------- HUD top-left ----------
  const KMH_PER_UNIT = 0.18;
  function formatTime(t){
    const m=Math.floor(t/60);
    const s=t-m*60;
    return `${m}:${s.toFixed(2).padStart(5,"0")}`;
  }

  function drawSpeedTimeAndHits(){
    const me=ships[0];
    if(!me) return;

    const sp = hypot(me.vx,me.vy);
    const kmh = Math.max(0, Math.round(sp * KMH_PER_UNIT));
    bestKmh = Math.max(bestKmh, kmh);

    ctx.save();
    ctx.globalAlpha=0.55;
    ctx.fillStyle="rgba(10,16,34,0.65)";
    ctx.strokeStyle="rgba(180,210,255,0.18)";
    ctx.lineWidth=1;
    const w=220, h=106;
    ctx.beginPath();
    ctx.roundRect(12, 10, w, h, 14);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.textAlign="left";
    ctx.textBaseline="top";
    ctx.globalAlpha=0.95;

    ctx.font="950 42px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.fillStyle="rgba(230,245,255,0.98)";
    ctx.fillText(`${String(kmh).padStart(3,"0")} Km/h`, 22, 18);

    ctx.font="800 18px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.fillStyle="rgba(230,245,255,0.85)";
    const timeTxt = (gameState==="race" && raceStarted) ? formatTime(raceTime) : "0:00.00";
    ctx.fillText(timeTxt, 24, 64);

    ctx.font="900 18px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.fillStyle="rgba(255,190,190,0.95)";
    ctx.fillText(`HITS: ${me.hits}/${MAX_HITS}`, 24, 86);

    ctx.restore();
  }

  // ---------- Bars bottom-left ----------
  function drawBars(){
    const me=ships[0];
    if(!me) return;
    const cp=Math.min(me.cpIndex,NUM_CPS);

    const w=Math.min(420, canvas.width*0.44), h=14;
    const x=20;
    const y0=canvas.height - (isMobile ? 320 : 210);
    const gap=36;

    ctx.save();
    ctx.textAlign="left";
    ctx.textBaseline="top";
    ctx.globalAlpha=0.95;

    ctx.font="950 24px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.fillStyle="rgba(230,245,255,0.92)";
    ctx.fillText(`CP ${cp}/${NUM_CPS}`, x, y0);

    ctx.globalAlpha=0.60;
    ctx.fillStyle="rgba(230,245,255,0.18)";
    ctx.fillRect(x, y0+34, w, h);
    ctx.globalAlpha=0.95;
    ctx.fillStyle="rgba(230,245,255,0.60)";
    ctx.fillRect(x, y0+34, w*(cp/NUM_CPS), h);

    ctx.globalAlpha=0.95;
    ctx.fillStyle="rgba(230,245,255,0.92)";
    ctx.fillText("BOOST", x, y0+34+gap);
    ctx.globalAlpha=0.60;
    ctx.fillStyle="rgba(230,245,255,0.18)";
    ctx.fillRect(x, y0+34+gap+34, w, h);
    ctx.globalAlpha=0.95;
    ctx.fillStyle="rgba(120,210,255,0.70)";
    ctx.fillRect(x, y0+34+gap+34, w*clamp(me.boostEnergy,0,1), h);

    ctx.restore();
  }

  function updateHUD(){
    const me = ships[0];
    if(!me){ statusEl.textContent="Listo"; return; }
    const cp=Math.min(me.cpIndex,NUM_CPS);
    statusEl.innerHTML = `CP: <b>${cp}/${NUM_CPS}</b> · Boost: <b>${Math.round(me.boostEnergy*100)}%</b> · Hits: <b>${me.hits}/${MAX_HITS}</b>`;
  }

  // ---------- Draw ship ----------
  function drawShip(ship){
    if(ship.destroyed) return;
    const img = ship.sprite;
    const ready = ship.spriteReady;
    const p=worldToScreen(ship.x,ship.y);

    const baseScale = ready ? (SHIP_WORLD_W / img.width) : 1;
    const scale = baseScale * camera.zoom;

    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(ship.ang + Math.PI/2);
    if(ready){
      const w=img.width*scale;
      const h=img.height*scale;
      ctx.drawImage(img, -w/2, -h/2, w, h);
    }
    ctx.restore();
  }

  // ---------- Countdown overlay ----------
  function drawCountdownOverlay(){
    if(gameState!=="race" || raceStarted) return;
    ctx.save();
    ctx.fillStyle="rgba(0,0,0,0.30)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    let text="GO!";
    if(countdown>2.2) text="3";
    else if(countdown>1.2) text="2";
    else if(countdown>0.2) text="1";

    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.font="900 92px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.fillStyle="rgba(230,245,255,0.96)";
    ctx.fillText(text, canvas.width/2, canvas.height/2 - 10);
    ctx.restore();
  }

  function drawDestroyedMessage(){
    if(gameState!=="destroyed") return;
    ctx.save();
    ctx.fillStyle="rgba(0,0,0,0.42)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.font="950 40px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.fillStyle="rgba(230,245,255,0.98)";
    ctx.fillText("SU PROTOTIPO DE ICARUS HA SIDO DESTRUÍDO", canvas.width/2, canvas.height/2);

    ctx.restore();
  }

  // ---------- Track lines ----------
  function drawStartFinish(){
    drawLine(startLine,"rgba(160,255,200,0.85)",5);
    drawLine(finishLine,"rgba(255,220,140,0.88)",6);
  }

  // ---------- Post results ----------
  function showPostResults(me){
    gameState="post";
    postUI.style.display="grid";

    const kmh = bestKmh;
    postPlace = me.place || 1;
    const txt =
`HAS QUEDADO EN ${postPlace} POSICIÓN

Velocidad máxima: ${kmh} Km/h
Tiempo: ${formatTime(raceTime)}
Checkpoints: ${Math.min(me.cpIndex, NUM_CPS)}/${NUM_CPS}
Hits: ${me.hits}/${MAX_HITS}`;
    postStats.textContent = txt;
  }

  // ---------- Collisions: ship-ship ----------
  function resolveShipShipCollisions(){
    const r = shipCollisionRadius();
    const minRelSpeedForHit = 240; // clave: evita hits “fantasma” a baja velocidad
    for(let i=0;i<ships.length;i++){
      const a=ships[i];
      if(a.destroyed) continue;
      for(let j=i+1;j<ships.length;j++){
        const b=ships[j];
        if(b.destroyed) continue;

        const dx=b.x-a.x, dy=b.y-a.y;
        const d=Math.hypot(dx,dy) || 1e-6;
        const minD=r+r;
        if(d < minD){
          const nx=dx/d, ny=dy/d;

          // Separate
          const push=(minD-d)*0.52;
          a.x -= nx*push; a.y -= ny*push;
          b.x += nx*push; b.y += ny*push;

          // Relative speed along normal
          const relvx = (b.vx - a.vx);
          const relvy = (b.vy - a.vy);
          const relN = relvx*nx + relvy*ny;

          // Bounce (visible)
          const bounce = 0.55;
          if(relN < 0){
            const imp = -relN * bounce;
            a.vx -= nx*imp; a.vy -= ny*imp;
            b.vx += nx*imp; b.vy += ny*imp;
          }

          // Hits only if meaningful
          const relSpeed = Math.hypot(relvx, relvy);
          if(relSpeed > minRelSpeedForHit){
            applyHit(a,1);
            applyHit(b,1);
            spawnHitSparks((a.x+b.x)*0.5, (a.y+b.y)*0.5, 16);
          }
        }
      }
    }
  }

  // ---------- Update ship audio mix ----------
  function updateShipAudioMix(dt, ship){
    if(!shipAudio.enabled || !shipAudio.started || !ship || ship.destroyed) return;
    shipAudio.hitCD = Math.max(0, shipAudio.hitCD - dt);

    const speed = Math.hypot(ship.vx, ship.vy);
    const s01 = Math.max(0, Math.min(1, speed / 1750));
    const throttle = ship.thrust || 0;
    const boosting = ship.boost ? 1 : 0;
    const braking = (ship.brake && !ship.reverse) ? 1 : 0;

    const targetIdle     = 0.10 + s01*0.22;
    const targetThrottle = throttle * (0.10 + s01*0.50);
    const targetBoost    = boosting * (0.22 + s01*0.55);
    const targetBrake    = braking * (0.10 + s01*0.28);

    const smooth = 1 - Math.pow(0.0008, dt);

    shipAudio.vIdle     += (targetIdle     - shipAudio.vIdle)     * smooth;
    shipAudio.vThrottle += (targetThrottle - shipAudio.vThrottle) * smooth;
    shipAudio.vBoost    += (targetBoost    - shipAudio.vBoost)    * smooth;
    shipAudio.vBrake    += (targetBrake    - shipAudio.vBrake)    * smooth;

    shipAudio.idle.volume     = clamp(shipAudio.vIdle,     0, 1);
    shipAudio.throttle.volume = clamp(shipAudio.vThrottle, 0, 1);
    shipAudio.boost.volume    = clamp(shipAudio.vBoost,    0, 1);
    shipAudio.brake.volume    = clamp(shipAudio.vBrake,    0, 1);

    const baseRate = 0.95 + s01*0.35;
    shipAudio.idle.playbackRate     = clamp(baseRate, 0.75, 1.35);
    shipAudio.throttle.playbackRate = clamp(baseRate + throttle*0.15, 0.75, 1.55);
    shipAudio.boost.playbackRate    = clamp(baseRate + 0.18, 0.75, 1.75);
    shipAudio.brake.playbackRate    = 1.0;
  }

  // ---------- Update ship physics + meteor collisions (fixed) ----------
  function updateShip(ship, dt){
    if(ship.destroyed) return;

    ship.hitCD=Math.max(0,ship.hitCD-dt);

    ship.px = ship.x; ship.py = ship.y;

    if(gameState==="race"){
      if(!raceStarted){
        ship.thrust=0; ship.brake=0; ship.boost=0; ship.reverse=0; ship.steer*=0.6;
      }else if(!ship.finished){
        if(ship.isAI) handleAI(ship, dt);
        else handlePlayer(ship, dt);
      }else{
        ship.boost=0; ship.thrust=0; ship.brake=1; ship.reverse=0;
      }
    } else {
      ship.thrust=0; ship.brake=0; ship.boost=0; ship.reverse=0;
    }

    if(ship.boost){
      ship.boostEnergy = Math.max(0, ship.boostEnergy - BOOST_DRAIN_PER_SEC*dt);
      if(ship.boostEnergy <= 0.01) ship.boost=0;
    }

    const speed=hypot(ship.vx,ship.vy);
    const speed01=clamp(speed/1300,0,1);
    const turn=ship.turnRate*(0.70 + speed01*0.85);
    ship.ang += ship.steer*turn*dt;

    let acc = ship.accel*ship.thrust;
    if(ship.boost) acc *= ship.boostAccelMul;
    if(ship.reverse) acc = -ship.accel*0.55;

    ship.vx += Math.cos(ship.ang)*acc*dt;
    ship.vy += Math.sin(ship.ang)*acc*dt;

    if(ship.brake && !ship.reverse){
      const pow = ship.brakePower || 1.0;
      ship.vx *= Math.pow(0.02, dt * pow);
      ship.vy *= Math.pow(0.02, dt * pow);
    }

    const forward = Math.cos(ship.ang)*ship.vx + Math.sin(ship.ang)*ship.vy;
    ship.vx = lerp(Math.cos(ship.ang)*forward, ship.vx, ship.drift);
    ship.vy = lerp(Math.sin(ship.ang)*forward, ship.vy, ship.drift);

    const maxV = ship.reverse ? 430 : (ship.boost ? ship.boostMax : ship.baseMax);
    const v=hypot(ship.vx,ship.vy);
    if(v>maxV){
      const k=maxV/(v||1);
      ship.vx*=k; ship.vy*=k;
    }

    const fr = ship.boost ? 0.86 : 0.72;
    ship.vx *= Math.pow(fr, dt);
    ship.vy *= Math.pow(fr, dt);

    ship.x += ship.vx*dt;
    ship.y += ship.vy*dt;

    const t=nearestOnTrack(ship.x,ship.y);
    ship.progress=t.prog;
    ship.maxProgress=Math.max(ship.maxProgress, ship.progress);

    // Walls
    const limit=TRACK_W*0.5;
    const over=Math.abs(t.hit.side)-limit;
    if(over>0){
      const sign=Math.sign(t.hit.side);
      ship.x -= t.hit.lx*over*sign;
      ship.y -= t.hit.ly*over*sign;

      const vn = ship.vx*t.hit.lx + ship.vy*t.hit.ly;
      const vt = ship.vx*t.hit.ux + ship.vy*t.hit.uy;

      const vn2 = -vn*(1 - WALL_BOUNCE);
      const vt2 = vt*(1 - WALL_TANGENTIAL_LOSS);

      ship.vx = t.hit.lx*vn2 + t.hit.ux*vt2;
      ship.vy = t.hit.ly*vn2 + t.hit.uy*vt2;
    }

    // Checkpoints
    if(gameState!=="menu"){
      while(ship.cpIndex<NUM_CPS && ship.maxProgress >= (checkpoints[ship.cpIndex].s - 80)){
        ship.cpIndex++;
        awardBoostEnergy(ship, BOOST_GAIN_PER_CP);
        if(!ship.isAI && gameState==="race") beepCheckpoint();
      }
    }

    // Meteor collisions (continuous + correct resolution)
    if(gameState!=="menu"){
      const sr=shipCollisionRadius();
      for(const m of meteorites){
        if(!m.alive) continue;
        if(m.solidCooldown > 0) continue;

        const rr = (m.r) + sr; // back to reliable collision
        const hit = pointSegClosest(m.x,m.y, ship.px,ship.py, ship.x,ship.y);

        if(hit.d2 < rr*rr){
          m.solidCooldown = 0.75;

          // Compute normal from meteor center to closest point on ship path
          let nx = (hit.cx - m.x);
          let ny = (hit.cy - m.y);
          let nd = Math.hypot(nx,ny) || 1e-6;
          nx/=nd; ny/=nd;

          if(ship.boost && gameState==="race" && raceStarted){
            // break
            m.alive=false;
            spawnMeteorShards(m.x,m.y,m.r,ship);
            sfxAsteroidBreak();
            awardBoostEnergy(ship, BOOST_GAIN_PER_BREAK);
          }else{
            sfxImpact();
            applyHit(ship, 1);

            // Place ship outside the meteor at impact position (visible, no “ghost hit”)
            const pushOut = (rr - Math.sqrt(hit.d2)) + 2;
            ship.x = ship.x + nx * pushOut;
            ship.y = ship.y + ny * pushOut;

            // Reflect velocity (bounce back a bit)
            const vn = ship.vx*nx + ship.vy*ny;
            if(vn < 0){
              ship.vx -= nx * (1.6*vn);
              ship.vy -= ny * (1.6*vn);
            }
            ship.vx *= 0.78;
            ship.vy *= 0.78;

            // Feedback sparks at contact
            spawnHitSparks(hit.cx, hit.cy, 18);
          }
        }
      }
    }

    // Finish
    if(gameState==="race" && !ship.finished && ship.cpIndex>=NUM_CPS && ship.maxProgress >= finishS - 40){
      ship.finished=true;
      ship.finishTime=raceTime;
    }
  }

  // ---------- Menu ----------
  const INTRO_TEXT =
`¡Bienvenid@s pilotos!

Abróchense bien los cinturones y prepárense para demostrar sus habilidades en este simulador de carreras con la tecnología de hipermotores ICARUS.

La Confederación del Pacífico se enorgullece de presentarles la nueva línea de modelos ICARUS 3, con los que podrá correr y testear su velocidad por el exterior de la atmósfera terrestre.

Gracias por formar parte de este programa para pilotos avanzados como usted.

Gracias a sus progresos, podremos desarrollar nuevos y mejores modelos para optimizar la construcción de la futura primera colonia lunar.

3,2,1...GO!`;

  const tips = [
    "Tip: Rompe meteoritos con BOOST para recargar más.",
    "Tip: Mantén ↓ 2s para activar marcha atrás.",
    "Tip: 10 golpes y tu prototipo queda destruido.",
    "Tip: Los checkpoints también te dan BOOST extra."
  ];
  let lastTipIdx = -1;
  function nextTip(){
    if(tips.length <= 1) return tips[0] || "";
    let idx = lastTipIdx;
    while(idx === lastTipIdx){
      idx = Math.floor(Math.random()*tips.length);
    }
    lastTipIdx = idx;
    return tips[idx];
  }

  let menuMode = "main";
  let typeTimer = null;
  let typedIndex = 0;

  function clearTypewriter(){
    if(typeTimer){ clearInterval(typeTimer); typeTimer=null; }
    typedIndex = 0;
  }

  function renderMenu(){
    clearTypewriter();
    stopIntroNarr();

    if(menuMode === "main"){
      const tip = nextTip();

      menuContent.innerHTML = `
        <button class="menuBtn primaryGold" id="startRace">START RACE</button>
        <button class="menuBtn secondary" id="howTo">Cómo jugar</button>
        <button class="menuBtn secondary" id="intro">Introducción</button>
        <button class="menuBtn secondary" id="discoverIcarus">Descubre ICARUS</button>
        <div class="tipLine">${tip}</div>
      `;

      menuContent.querySelector("#startRace").addEventListener("click", ()=>{
        menuMode = "select";
        renderMenu();
      });

      menuContent.querySelector("#discoverIcarus").addEventListener("click", ()=>{
        window.open("https://www.disturbingstories.com/012.html","_blank","noopener,noreferrer");
      });

      menuContent.querySelector("#howTo").addEventListener("click", ()=>{
        menuMode="howto"; renderMenu();
      });

      menuContent.querySelector("#intro").addEventListener("click", ()=>{
        menuMode="intro"; renderMenu();
      });

    } else if(menuMode === "select"){
      const items = shipDefs.map(s => `
        <div class="shipCard ${s.id===selectedShipId ? "selected":""}" data-ship="${s.id}">
          <div class="shipImg"><img src="imagen/nave_${s.id}.png" alt="ship ${s.id}"></div>
          <div class="shipName">${s.label}</div>
          <div class="shipMeta">${s.blurb}</div>
        </div>
      `).join("");

      menuContent.innerHTML = `
        <div class="subTitle">Selecciona tu nave</div>
        <div class="shipGrid">${items}</div>
        <button class="menuBtn primaryGold" id="confirmShip">CONFIRMAR Y EMPEZAR</button>
        <button class="menuBtn secondary" id="backMenu">VOLVER A MENU</button>
      `;

      menuContent.querySelectorAll(".shipCard").forEach(el=>{
        el.addEventListener("click", ()=>{
          selectedShipId = el.dataset.ship;
          renderMenu();
        });
      });

      menuContent.querySelector("#confirmShip").addEventListener("click", async ()=>{
        await playMenuMusic();
        await startShipAudioLoops();
        startRaceFlow();
      });

      menuContent.querySelector("#backMenu").addEventListener("click", ()=>{
        menuMode="main";
        renderMenu();
      });

    } else if(menuMode === "howto"){
      menuContent.innerHTML = `
        <div class="subTitle">Cómo jugar</div>
        <div class="subText">
🎯 Objetivo: completa el circuito desde START hasta FINISH antes que tus rivales, usando BOOST y habilidad para esquivar meteoritos.

🔹 Rompe meteoritos con BOOST.
🔹 Rebufo = recarga extra.
🔹 Cada checkpoint recarga un poco.
🔹 25 checkpoints + FINISH.

🚀 ↑  Acelerar
🛑 ↓  Frenar (mantén 2s para marcha atrás)
↩️  ←/→ Girar
⚡ Espacio  BOOST (consume energía)
✅ Checkpoints recargan BOOST
💥  10 golpes = nave destruida
        </div>
        <button class="menuBtn secondary" id="backMenu">VOLVER A MENU</button>
      `;
      menuContent.querySelector("#backMenu").addEventListener("click", ()=>{
        menuMode="main"; renderMenu();
      });

    } else if(menuMode === "intro"){
      menuContent.innerHTML = `
        <div class="subTitle">Introducción</div>
        <div class="subText centered" id="introBox"></div>
        <button class="menuBtn secondary" id="backMenu">VOLVER A MENU</button>
      `;
      menuContent.querySelector("#backMenu").addEventListener("click", ()=>{
        menuMode="main"; renderMenu();
      });

      const box = menuContent.querySelector("#introBox");
      typedIndex = 0;

      playIntroNarr();

      typeTimer = setInterval(()=>{
        typedIndex += 1 + (Math.random() < 0.10 ? 1 : 0);
        box.textContent = INTRO_TEXT.slice(0, typedIndex);
        if(typedIndex >= INTRO_TEXT.length){
          clearTypewriter();
          box.textContent = INTRO_TEXT;
        }
      }, 44);
    }
  }

  // ---------- Flow ----------
  async function showMenu(){
    postUI.style.display="none";
    if(touchControls) touchControls.classList.add("hidden");
    gameState="menu";
    menuMode="main";
    renderMenu();
    menuEl.style.display="grid";

    
    if(touchControlsEl) touchControlsEl.classList.add("hidden");
// Asegura que el video del menú está visible y vuelve a reproducirse (mobile-safe)
    menuVideo.style.display = "block";
    menuVideo.style.opacity = "1";
    menuVideo.style.visibility = "visible";
    try{ menuVideo.currentTime = Math.max(0, menuVideo.currentTime); }catch{}


    stopRaceMusic();
    stopShipAudioAll();

    try{ await menuVideo.play(); }catch{}
    await playMenuMusic();

    bestKmh = 0;
  }

  function startRaceFlow(){
    postUI.style.display="none";
    if(touchControls) touchControls.classList.toggle("hidden", !isMobile);
    shipAudio.startPlayed = false;

    stopMenuMusic();
    stopIntroNarr();
    playRaceMusic();

    gameState="race";
    menuEl.style.display="none";

    

    if(touchControlsEl) touchControlsEl.classList.remove("hidden");
countdown=3.2;
    raceStarted=false;
    raceTime=0;
    bestKmh=0;

    resetRaceEntities(true);
  }

  function resetRaceEntities(genMets){
    particles.length=0;
    speedLines.length=0;
    ships.length=0;

    if(genMets) generateMeteorites();

    const s0=20;
    const p0=sampleAt(main,s0);
    const ang0=Math.atan2(p0.uy,p0.ux);

    const offsets=[-120,-40,40,120];

    const def = shipDefs.find(d=>d.id===selectedShipId) || shipDefs[1];

    const player = makeShip({
      name:"Tú",
      x:p0.x + p0.nx*offsets[0],
      y:p0.y + p0.ny*offsets[0],
      ang:ang0,
      boostEnergy:1.0,
      sprite: def.img,
      spriteReady: def.ready()
    });
    def.tune(player);
    ships.push(player);

    ships.push(makeShip({
      name:"Nova", isAI:true, aiSkill:0.86,
      x:p0.x + p0.nx*offsets[1],
      y:p0.y + p0.ny*offsets[1],
      ang:ang0,
      boostEnergy:1.0,
      sprite: aiShipImg, spriteReady: aiShipReady
    }));
    ships.push(makeShip({
      name:"Kite", isAI:true, aiSkill:0.84,
      x:p0.x + p0.nx*offsets[2],
      y:p0.y + p0.ny*offsets[2],
      ang:ang0,
      boostEnergy:1.0,
      sprite: aiShipImg, spriteReady: aiShipReady
    }));
    ships.push(makeShip({
      name:"Vex", isAI:true, aiSkill:0.88,
      x:p0.x + p0.nx*offsets[3],
      y:p0.y + p0.ny*offsets[3],
      ang:ang0,
      boostEnergy:1.0,
      sprite: aiShipImg, spriteReady: aiShipReady
    }));

    camera.x=p0.x; camera.y=p0.y; camera.zoom=0.74;
    initDepthDots();
  }

  // Post UI button
  postMenuBtn.addEventListener("click", ()=>{
    showMenu();
  });

  // Restart
  restartBtn.addEventListener("click",()=>{
    if(gameState==="race"){
      countdown=3.2; raceStarted=false; raceTime=0;
      bestKmh=0;
      resetRaceEntities(true);
      shipAudio.startPlayed = false;
      postUI.style.display="none";
    } else {
      showMenu();
    }
  });

  // Mobile/desktop: exit current race to main menu
  exitToMenuBtn.addEventListener("click", ()=>{
    showMenu();
  });

  // Gesture unlock: if music got blocked, this click will start it
  document.body.addEventListener("click", async ()=>{
    if(introOverlay.style.display !== "none") return;
    if(menuEl.style.display !== "none"){
      try{ await playMenuMusic(); }catch{}
    }
  }, { once:false });

  // ---------- Patterns ----------
  function setPatternWorldTransform(pat, img, extraScrollPx){
    if(!pat || !pat.setTransform || !img || !img.width) return false;
    const z = camera.zoom;
    const tileScale = z * 0.85;
    const tx = (-camera.x * z) + canvas.width/2;
    const ty = (-camera.y * z) + canvas.height/2 + extraScrollPx;
    const m = new DOMMatrix();
    m.translateSelf(tx, ty);
    m.scaleSelf(tileScale, tileScale);
    pat.setTransform(m);
    return true;
  }

  // ---------- Main loop ----------
  let last=performance.now();
  function tick(now){
    const dt=clamp((now-last)/1000, 0, 0.033);
    last=now;

    if(gameState==="race"){
      if(!raceStarted){
        countdown -= dt;
        if(countdown <= 0){
          raceStarted=true;
          countdown=0;
          playShipStartOnce();
        }
      } else {
        raceTime += dt;
      }
    }

    if(gameState==="race" || gameState==="post" || gameState==="destroyed"){
      for(const sh of ships) updateShip(sh, dt);
      resolveShipShipCollisions();

      updateMeteorites(dt);
      updateParticles(dt);

      // ranking
      const ranked = ships.slice().filter(s=>!s.destroyed).map(sh=>{
        const prog = sh.finished ? (finishS+9999) : sh.maxProgress;
        const t = sh.finishTime ?? Infinity;
        return {sh, prog, t};
      }).sort((a,b)=>{
        if(a.sh.finished && b.sh.finished) return a.t - b.t;
        if(a.sh.finished) return -1;
        if(b.sh.finished) return 1;
        return b.prog - a.prog;
      });
      ranked.forEach((r,idx)=>r.sh.place=idx+1);

      const me=ships[0];
      updateCamera(dt);

      if((gameState==="race" || gameState==="post") && me && !me.destroyed){
        updateShipAudioMix(dt, me);
      }

      if(gameState==="race" && raceStarted && me && me.boost){
        updateSpeedLines(dt, clamp(Math.hypot(me.vx,me.vy)/(me.boostMax||1),0,1));
      }

      updateHUD();

      // Finish -> show results (stay)
      if(gameState==="race" && me && me.finished && !me.destroyed){
        bestKmh = Math.max(bestKmh, Math.round(Math.hypot(me.vx,me.vy)*KMH_PER_UNIT));
        showPostResults(me);
      }

      // render
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawStars();
      drawEarthScroll();
      drawDepthDots(dt);

      drawTrackTextured(main, 0.92);
      for(const br of branches) drawTrackTextured(br, 0.70);
      drawCheckpoints();
      drawStartFinish();
      drawMeteorites();
      drawMeteorShards();

      // particles
      ctx.save();
      for(const p of particles){
        const s=worldToScreen(p.x,p.y);
        ctx.globalAlpha=clamp(p.life*2.2,0,1);
        ctx.fillStyle=p.c;
        ctx.beginPath(); ctx.arc(s.x,s.y,p.r*camera.zoom,0,TAU2); ctx.fill();
      }
      ctx.restore();

      for(const r of ranked.slice().reverse()){
        drawShip(r.sh);
      }

      if(gameState==="race" && raceStarted && me && me.boost) drawSpeedLinesOverlay();

      drawSpeedTimeAndHits();
      drawBars();
      drawCountdownOverlay();
      drawDestroyedMessage();

    } else {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const p0=sampleAt(main,30);
      camera.x=lerp(camera.x,p0.x,0.04);
      camera.y=lerp(camera.y,p0.y,0.04);
      camera.zoom=lerp(camera.zoom,0.76,0.04);

      drawStars();
      drawEarthScroll();
      drawDepthDots(dt);
      drawTrackTextured(main, 0.75);
      drawStartFinish();
      updateHUD();
    }

    requestAnimationFrame(tick);
  }

  // ---------- Boot ----------
  updateLoadStatus();
  initDepthDots();
  generateMeteorites();

  // Start intro immediately on load
  tryPlayIntro();

  // Game loop runs even during intro (fine), but menu hidden until intro ends
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>
